/* Standard libraries */
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tice.h>

/* Shared libraries */
#include <graphx.h>
#include <keypadc.h>

#include "gfx\gfx.h"
#include "gfx\font.h"

#define COLOR_RED			0x00
#define COLOR_BLACK			0x01
#define COLOR_WHITE			0x02
#define COLOR_GRAY_1		0x03
#define COLOR_GRAY_2		0x04
#define COLOR_GRAY_3		0x05
#define COLOR_GRAY_4		0x06
#define COLOR_GRAY_5		0x07
#define COLOR_GRAY_6		0x08
#define COLOR_GRAY_7		0x09
#define COLOR_SCORE_BLUE	0x0A

/* Block defines */
#define BLOCK_EMPTY 		0x00
#define BLOCK_RED 			0x01
#define BLOCK_ORANGE 		0x02
#define BLOCK_YELLOW 		0x03
#define BLOCK_LIME_GREEN 	0x04
#define BLOCK_GREEN 		0x05
#define BLOCK_DARK_GREEN 	0x06
#define BLOCK_TURQUOISE 	0x07
#define BLOCK_CYAN 			0x08
#define BLOCK_LIGHT_BLUE	0x09
#define BLOCK_BLUE 			0x0A
#define BLOCK_PURPLE 		0x0B
#define BLOCK_MAGENTA 		0x0C
#define BLOCK_PINK 			0x0D
#define BLOCK_HOT_PINK 		0x0E
#define BLOCK_BUMPER_1 		0x0F
#define BLOCK_BUMPER_2 		0x10
#define BLOCK_INVISIBLE 	0x11
#define BLOCK_VISIBLE 		0x12


/* Tilemap defines */
#define TILE_WIDTH          14
#define TILE_HEIGHT        	7

#define TILEMAP_WIDTH       20
#define TILEMAP_HEIGHT      22

#define TILEMAP_DRAW_WIDTH  20
#define TILEMAP_DRAW_HEIGHT 22

#define X_OFFSET            20
#define Y_OFFSET            17

uint8_t lvl1_map[TILEMAP_WIDTH * TILEMAP_HEIGHT] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x16, 0x01, 0x01, 0x01, 0x16, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x16, 0x0E, 0x0E, 0x0E, 0x16, 0x0E, 0x0E, 0x0E, 0x16, 0x0E, 0x0E, 0x0E, 0x16, 0x0E, 0x0E, 0x0E, 0x00, 0x00,
	0x00, 0x16, 0x0C, 0x0C, 0x0C, 0x16, 0x0C, 0x0C, 0x0C, 0x16, 0x0C, 0x0C, 0x0C, 0x16, 0x0C, 0x0C, 0x0C, 0x16, 0x0C, 0x00,
	0x16, 0x0B, 0x0B, 0x0B, 0x16, 0x0B, 0x0B, 0x0B, 0x16, 0x0B, 0x0B, 0x0B, 0x16, 0x0B, 0x0B, 0x0B, 0x16, 0x0B, 0x0B, 0x0B,
	0x0C, 0x0C, 0x0C, 0x16, 0x0C, 0x0C, 0x0C, 0x16, 0x0C, 0x0C, 0x0C, 0x16, 0x0C, 0x0C, 0x0C, 0x16, 0x0C, 0x0C, 0x0C, 0x16,
	0x0E, 0x0E, 0x16, 0x0E, 0x0E, 0x0E, 0x16, 0x0E, 0x0E, 0x0E, 0x16, 0x0E, 0x0E, 0x0E, 0x16, 0x0E, 0x0E, 0x0E, 0x16, 0x0E,
	0x01, 0x16, 0x01, 0x01, 0x01, 0x16, 0x01, 0x01, 0x01, 0x16, 0x01, 0x01, 0x01, 0x16, 0x01, 0x01, 0x01, 0x16, 0x01, 0x01,
	0x00, 0x0E, 0x0E, 0x0E, 0x16, 0x0E, 0x0E, 0x0E, 0x16, 0x0E, 0x0E, 0x0E, 0x16, 0x0E, 0x0E, 0x0E, 0x16, 0x0E, 0x0E, 0x00,
	0x00, 0x00, 0x0C, 0x16, 0x0C, 0x0C, 0x0C, 0x16, 0x0C, 0x0C, 0x0C, 0x16, 0x0C, 0x0C, 0x0C, 0x16, 0x0C, 0x0C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x16, 0x0B, 0x0B, 0x0B, 0x16, 0x0B, 0x0B, 0x0B, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

uint8_t lvl2_map[TILEMAP_WIDTH * TILEMAP_HEIGHT] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x16, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x16, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x16, 0x0F, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x0F, 0x16, 0x00, 0x00,
	0x00, 0x16, 0x0F, 0x0B, 0x0F, 0x0F, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x0F, 0x0F, 0x0B, 0x0F, 0x16, 0x00,
	0x16, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0F, 0x00, 0x16, 0x00, 0x00, 0x16, 0x00, 0x0F, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x16,
	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x16, 0x0B, 0x0F, 0x00, 0x16, 0x16, 0x00, 0x0F, 0x0B, 0x16, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x0A, 0x16, 0x0B, 0x0F, 0x00, 0x00, 0x0F, 0x0B, 0x16, 0x0A, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x10, 0x10, 0x16, 0x16, 0x05, 0x05, 0x0A, 0x16, 0x0B, 0x0F, 0x0F, 0x0B, 0x16, 0x0A, 0x05, 0x05, 0x16, 0x16, 0x10, 0x10,
	0x16, 0x02, 0x10, 0x10, 0x16, 0x05, 0x05, 0x0A, 0x16, 0x0B, 0x0B, 0x16, 0x0A, 0x05, 0x05, 0x16, 0x10, 0x10, 0x02, 0x16,
	0x01, 0x16, 0x02, 0x02, 0x10, 0x16, 0x05, 0x05, 0x0A, 0x16, 0x16, 0x0A, 0x05, 0x05, 0x16, 0x10, 0x02, 0x02, 0x16, 0x01,
	0x11, 0x01, 0x16, 0x02, 0x02, 0x10, 0x16, 0x05, 0x05, 0x0A, 0x0A, 0x05, 0x05, 0x16, 0x10, 0x02, 0x02, 0x16, 0x01, 0x11,
	0x00, 0x11, 0x01, 0x16, 0x02, 0x02, 0x10, 0x16, 0x05, 0x05, 0x05, 0x05, 0x16, 0x10, 0x02, 0x02, 0x16, 0x01, 0x11, 0x00,
	0x00, 0x00, 0x11, 0x01, 0x16, 0x02, 0x02, 0x10, 0x16, 0x05, 0x05, 0x16, 0x10, 0x02, 0x02, 0x16, 0x01, 0x11, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x11, 0x01, 0x16, 0x02, 0x02, 0x10, 0x16, 0x16, 0x10, 0x02, 0x02, 0x16, 0x01, 0x11, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x11, 0x01, 0x16, 0x02, 0x02, 0x10, 0x10, 0x02, 0x02, 0x16, 0x01, 0x11, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x01, 0x16, 0x02, 0x02, 0x02, 0x02, 0x16, 0x01, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x01, 0x16, 0x01, 0x01, 0x16, 0x01, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x01, 0x16, 0x16, 0x01, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

struct Ball {
	double x, y, vx, vy, speed, angle;
	uint8_t radius;
};

struct Block {
	uint8_t row;
	uint8_t col;
	uint8_t value;
};

bool is_same(struct Block a, struct Block b) {
	return a.row == b.row && a.col == b.col && a.value == b.value;
}

uint8_t color_i = 0;
uint8_t i, j;
int PaddleX = 135, PaddleXCenter, PaddleYCenter = 228;
struct Ball ball;
float BallAngle;
int moving = 0;
uint8_t key;
uint16_t score = 0;
uint8_t score_modifier = 10;

bool block_exists(struct Block block) {
	return block.col >= 0 && block.col < TILEMAP_WIDTH && block.row >= 0 && block.row < TILEMAP_HEIGHT;
}

void explode(gfx_tilemap_t *tilemap, uint8_t col, uint8_t row) {

	struct Block left = { row, col - 1, gfx_GetTileMapped(tilemap, col - 1, row)};
	struct Block up = { row - 1, col, gfx_GetTileMapped(tilemap, col, row - 1)};
	struct Block right = { row, col + 1, gfx_GetTileMapped(tilemap, col + 1, row)};
	struct Block down = { row + 1, col, gfx_GetTileMapped(tilemap, col, row + 1)};
	struct Block left_up = { row - 1, col - 1, gfx_GetTileMapped(tilemap, col - 1, row - 1)};
	struct Block right_up = { row - 1, col + 1, gfx_GetTileMapped(tilemap, col + 1, row - 1)};
	struct Block left_down = { row + 1, col - 1, gfx_GetTileMapped(tilemap, col - 1, row + 1)};
	struct Block right_down = { row + 1, col + 1, gfx_GetTileMapped(tilemap, col + 1, row + 1)};

	gfx_SetTileMapped(tilemap, col, row, 0x1A);
	
	if (block_exists(left) && left.value != 0x00) {
		gfx_SetTileMapped(tilemap, col - 1, row, 0x1A);
		score += score_modifier;
		if (left.value == 0x16 || left.value == 0x17 || left.value == 0x18 || left.value == 0x19)
			explode(tilemap, col - 1, row);
	}
	if (block_exists(up) && up.value != 0x00) {
		gfx_SetTileMapped(tilemap, col, row + 1, 0x1A);
		score += score_modifier;
		if (up.value == 0x16 || up.value == 0x17 || up.value == 0x18 || up.value == 0x19)
			explode(tilemap, col, row - 1);
	}
	if (block_exists(right) && right.value != 0x00) {
		gfx_SetTileMapped(tilemap, col + 1, row, 0x1A);
		score += score_modifier;
		if (right.value == 0x16 || right.value == 0x17 || right.value == 0x18 || right.value == 0x19)
			explode(tilemap, col + 1, row);
	}
	if (block_exists(down) && down.value != 0x00) {
		gfx_SetTileMapped(tilemap, col, row - 1, 0x1A);
		score += score_modifier;
		if (down.value == 0x16 || down.value == 0x17 || down.value == 0x18 || down.value == 0x19)
			explode(tilemap, col, row + 1);
	}
	if (block_exists(left_up) && left_up.value != 0x00) {
		gfx_SetTileMapped(tilemap, col - 1, row - 1, 0x1A);
		score += score_modifier;
		if (left_up.value == 0x16 || left_up.value == 0x17 || left_up.value == 0x18 || left_up.value == 0x19)
			explode(tilemap, col - 1, row - 1);
	}
	if (block_exists(right_up) && right_up.value != 0x00) {
		gfx_SetTileMapped(tilemap, col + 1, row - 1, 0x1A);
		score += score_modifier;
		if (right_up.value == 0x16 || right_up.value == 0x17 || right_up.value == 0x18 || right_up.value == 0x19)
			explode(tilemap, col + 1, row - 1);
	}
	if (block_exists(left_down) && left_down.value != 0x00) {
		gfx_SetTileMapped(tilemap, col - 1, row + 1, 0x1A);
		score += score_modifier;
		if (left_down.value == 0x16 || left_down.value == 0x17 || left_down.value == 0x18 || left_down.value == 0x19)
			explode(tilemap, col - 1, row + 1);
	}
	if (block_exists(right_down) && right_down.value != 0x00) {
		gfx_SetTileMapped(tilemap, col + 1, row + 1, 0x1A);
		score += score_modifier;
		if (right_down.value == 0x16 || right_down.value == 0x17 || right_down.value == 0x18 || right_down.value == 0x19)
			explode(tilemap, col + 1, row + 1);
	}
}

void draw_text(char* text, uint8_t color, uint16_t x, uint8_t y, int scale) {
	gfx_SetTextFGColor(color);
    gfx_SetTextBGColor(COLOR_RED);
    gfx_SetTextTransparentColor(COLOR_RED);
    gfx_SetTextXY(x, y);
	gfx_SetTextScale(scale, scale);
	gfx_PrintString(text);
}

void draw_int(int i, uint8_t color, uint16_t x, uint8_t y, int scale) {
	gfx_SetTextFGColor(color);
    gfx_SetTextBGColor(COLOR_RED);
    gfx_SetTextTransparentColor(COLOR_RED);
    gfx_SetTextXY(x, y);
	gfx_SetTextScale(scale, scale);
	gfx_PrintInt(i, 1);
}

void draw_bumpers(){
	unsigned char sideColors[15] = { COLOR_GRAY_1, COLOR_GRAY_2, COLOR_GRAY_3, COLOR_GRAY_4, COLOR_GRAY_5, COLOR_GRAY_6, COLOR_GRAY_7, COLOR_WHITE, COLOR_GRAY_7, COLOR_GRAY_6, COLOR_GRAY_5, COLOR_GRAY_4, COLOR_GRAY_3, COLOR_GRAY_2, COLOR_GRAY_1 };
	for( i = 0; i < 15; i++ ) {
		gfx_SetColor(sideColors[i]);
		gfx_VertLine_NoClip( i + 5, 0, 240 );
		gfx_VertLine_NoClip( i + 300, 0, 240 );
	}
}

void resetGame(){
	PaddleX = 135;
	PaddleYCenter = 232;
	ball.x = 165;
	ball.y = 219;
	moving = 0;
}

int main(void) {

	uint8_t tile = 0;

	ball.x = 165;
	ball.y = 219;
	ball.speed = 4;

	uint8_t animator = 0;

    gfx_tilemap_t tilemap;

    tilemap.map         = lvl1_map;
    tilemap.tiles       = tileset_tiles;
    tilemap.type_width  = gfx_tile_no_pow2;
    tilemap.type_height = gfx_tile_no_pow2;
    tilemap.tile_height = TILE_HEIGHT;
    tilemap.tile_width  = TILE_WIDTH;
    tilemap.draw_height = TILEMAP_DRAW_HEIGHT;
    tilemap.draw_width  = TILEMAP_DRAW_WIDTH;
    tilemap.height      = TILEMAP_HEIGHT;
    tilemap.width       = TILEMAP_WIDTH;
    tilemap.y_loc       = Y_OFFSET;
    tilemap.x_loc       = X_OFFSET;

	srand(rtc_Time());
    gfx_Begin(gfx_8bpp);
	gfx_SetPalette(global_palette, sizeof(global_palette), 0);
	gfx_SetTransparentColor(COLOR_RED);
	gfx_SetDrawBuffer();

	/* Set up the font */
    gfx_SetFontData(font);
    gfx_SetFontSpacing(font_spacing);
	gfx_SetFontHeight(7);

	while(!(kb_Data[6] & kb_Clear)){
		kb_Scan();
		key = kb_Data[7];
		PaddleXCenter = PaddleX + 31;
		ball.angle = atan2(PaddleYCenter - ball.y, PaddleXCenter - ball.x);
		gfx_FillScreen(COLOR_BLACK);
		draw_bumpers();
		draw_int(score, COLOR_SCORE_BLUE, 24, 4, 2);
        gfx_Tilemap_NoClip(&tilemap, 0, 0);
		for (i = 0; i < TILEMAP_HEIGHT; i++) {
			for (j = 0; j < TILEMAP_WIDTH; j++) {
				tile = gfx_GetTileMapped(&tilemap, j, i);
				if (tile == 0x16 || tile == 0x17 || tile == 0x18 || tile == 0x19) {
					if (animator % 4 == 0)
						tile++;
					if (tile > 0x19)
						tile = 0x16;
					gfx_SetTileMapped(&tilemap, j, i, tile);
				}
				if (tile == 0x1A || tile == 0x1B || tile == 0x1C || tile == 0x1D) {
					if (animator % 2 == 0)
						tile++;
					if (tile > 0x1D)
						tile = 0x00;
					gfx_SetTileMapped(&tilemap, j, i, tile);
				}
			}
		}
		animator++;
		if (animator > 100)
			animator = 0;
		gfx_SetColor(COLOR_GRAY_5);
		gfx_FillCircle_NoClip(ball.x, ball.y, 2);
		if (ball.x > X_OFFSET + ball.radius + 1 && ball.x < X_OFFSET + TILE_WIDTH * TILEMAP_WIDTH - ball.radius - 1 && ball.y > Y_OFFSET + ball.radius + 1 && ball.y < TILE_HEIGHT * TILEMAP_HEIGHT + Y_OFFSET - ball.radius - 1) {

			// Check for collisions between the ball and the blocks
			struct Block top, bottom, left, right, center;

			center.row = (ball.y - Y_OFFSET) / TILE_HEIGHT;
			center.col = (ball.x - X_OFFSET) / TILE_WIDTH;
			center.value = gfx_GetTileMapped(&tilemap, center.row, center.col);

			top.row = (ball.y - Y_OFFSET - ball.radius - 1) / TILE_HEIGHT;
			top.col = (ball.x - X_OFFSET) / TILE_WIDTH;
			top.value = gfx_GetTileMapped(&tilemap, top.col, top.row);

			bottom.row = (ball.y - Y_OFFSET + ball.radius + 1) / TILE_HEIGHT;
			bottom.col = (ball.x - X_OFFSET) / TILE_WIDTH;
			bottom.value = gfx_GetTileMapped(&tilemap, bottom.col, bottom.row);

			left.row = (ball.y - Y_OFFSET) / TILE_HEIGHT;
			left.col = (ball.x - X_OFFSET - ball.radius - 1) / TILE_WIDTH;
			left.value = gfx_GetTileMapped(&tilemap, left.col, left.row);

			right.row = (ball.y - Y_OFFSET) / TILE_HEIGHT;
			right.col = (ball.x - X_OFFSET + ball.radius + 1) / TILE_WIDTH;
			right.value = gfx_GetTileMapped(&tilemap, right.col, right.row);

			// Determine which side of the block the ball hit.
			if (top.value) {
				switch (top.value) {
					case 0x16:
					case 0x17:
					case 0x18:
					case 0x19:
						explode(&tilemap, top.col, top.row);
						break;
					case BLOCK_INVISIBLE:
						gfx_SetTileMapped(&tilemap, top.col, top.row, BLOCK_VISIBLE);
						break;
					case BLOCK_BUMPER_1:
						gfx_SetTileMapped(&tilemap, top.col, top.row, BLOCK_BUMPER_2);
						break;
					case BLOCK_BUMPER_2:
						break;
					default:
						gfx_SetTileMapped(&tilemap, top.col, top.row, BLOCK_EMPTY);
						break;
				}
				score += score_modifier;
				ball.vy = -ball.vy;
			} else if (bottom.value) {
				switch (bottom.value) {
					case 0x16:
					case 0x17:
					case 0x18:
					case 0x19:
						explode(&tilemap, bottom.col, bottom.row);
						break;
					case BLOCK_INVISIBLE:
						gfx_SetTileMapped(&tilemap, bottom.col, bottom.row, BLOCK_VISIBLE);
						break;
					case BLOCK_BUMPER_1:
						gfx_SetTileMapped(&tilemap, bottom.col, bottom.row, BLOCK_BUMPER_2);
						break;
					case BLOCK_BUMPER_2:
						break;
					default:
						gfx_SetTileMapped(&tilemap, bottom.col, bottom.row, BLOCK_EMPTY);
						break;
				}
				score += score_modifier;
				ball.vy = -ball.vy;
			}
			if (right.value) {
				switch (right.value) {
					case 0x16:
					case 0x17:
					case 0x18:
					case 0x19:
						explode(&tilemap, right.col, right.row);
						break;
					case BLOCK_INVISIBLE:
						gfx_SetTileMapped(&tilemap, right.col, right.row, BLOCK_VISIBLE);
						break;
					case BLOCK_BUMPER_1:
						gfx_SetTileMapped(&tilemap, right.col, right.row, BLOCK_BUMPER_2);
						break;
					case BLOCK_BUMPER_2:
						break;
					default:
						gfx_SetTileMapped(&tilemap, right.col, right.row, BLOCK_EMPTY);
						break;
				}
				score += score_modifier;
				ball.vx = -ball.vx;
			}
			if (left.value) {
				switch (left.value) {
					case 0x16:
					case 0x17:
					case 0x18:
					case 0x19:
						explode(&tilemap, left.col, left.row);
						break;
					case BLOCK_INVISIBLE:
						gfx_SetTileMapped(&tilemap, left.col, left.row, BLOCK_VISIBLE);
						break;
					case BLOCK_BUMPER_1:
						gfx_SetTileMapped(&tilemap, left.col, left.row, BLOCK_BUMPER_2);
						break;
					case BLOCK_BUMPER_2:
						break;
					default:
						gfx_SetTileMapped(&tilemap, left.col, left.row, BLOCK_EMPTY);
						break;
				}
				score += score_modifier;
				ball.vx = -ball.vx;
			}
			
		}
		gfx_SetColor(COLOR_GRAY_5);
		gfx_FillCircle_NoClip((uint16_t) ball.x, (uint8_t) ball.y, 2);
		gfx_TransparentSprite_NoClip(DX_Paddle, PaddleX, 223);
		if(key & kb_Left && PaddleX > 20) {
			PaddleX-=7;
			if(!moving)
				ball.x-=7;
		}
		if(key & kb_Right && PaddleX < 238) {
			PaddleX+=7;
			if(!moving)
				ball.x+=7;
		}
		if (PaddleX < 20) {
			PaddleX = 20;
		}
		if (PaddleX > 238) {
			PaddleX = 238;
		}
		if(kb_Data[1] & kb_2nd && !moving){
			moving = 1;
			ball.vx = -cos(ball.angle) * ball.speed;
			ball.vy = -sin(ball.angle) * ball.speed;
		}
		if(moving) {
			ball.x += ball.vx;
			ball.y += ball.vy;
		}
		if(ball.x > 298){
			ball.vx = -ball.vx;
			ball.x = 298;
		}
		if(ball.x < 22){
			ball.vx = -ball.vx;
			ball.x = 22;
		}
		if(ball.y < 2){
			ball.vy = -ball.vy;
			ball.y = 2;
		}
		if((ball.y > 221) && ((ball.x - 2 < (PaddleX + 62)) && ((ball.x + 2) > PaddleX) && (ball.y - 2 < 232) && ((ball.y + 2) > 223))){
			ball.vx = -cos(ball.angle) * ball.speed;
			ball.vy = -sin(ball.angle) * ball.speed;
			ball.y = 221;
		}
		if(ball.y >= 235)
			resetGame();
		if(PaddleX < 10)
			PaddleX = 10;
		if(PaddleX > 248)
			PaddleX = 248;
		gfx_SwapDraw();
	}
    gfx_End();
    pgrm_CleanUp();
}